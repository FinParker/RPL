# CVE-2021-29941-2

## Metadata

- RustSec: https://rustsec.org/advisories/RUSTSEC-2021-0050.html
- Mitre:
  - https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-29941
  - https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-29942
- Bug Report GitHub Issue/Release: issues/1
- Bug Fix GitHub Commit/PR:

## Source

```rust
pub fn swap_index(bla: impl ExactSizeIterator<Item = u32>) -> Vec<u32> {
    let len = bla.len();
    let mut vec = Vec::with_capacity(len);
    let arr: &mut [u32] = unsafe { std::slice::from_raw_parts_mut(vec.as_mut_ptr(), bla.len()) };
    for (i, a) in bla.enumerate() {
        arr[a as usize] = i as u32;
    }

    unsafe {
        vec.set_len(len);
    }
    vec
}

```

## Description / Analysis

`ExactSizeIterator`'s `len()`'s safety requirements are same as `size_hint()`:

`size_hint()` is primarily intended to be used for optimizations such as reserving space for the elements of the iterator, but must not be trusted to e.g., omit bounds checks in unsafe code. An incorrect implementation of `size_hint()` should not lead to memory safety violations.

`swap_index`:

- can return uninitialized values if an iterator returns a `len()` that is too large.
- has an out-of-bounds write if an iterator returns a `len()` that is too small.

## Fixes

Interestingly, the `README.md` of the crate mentions that it will reorder a slice based on a slice of indices **without** an auxiliary array.

However, the newest version of the crate needs an auxiliary array to work correctly.

## Pattern Description

TODO
