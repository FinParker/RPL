# CVE-2020-25795

## Metadata

- RustSec: https://rustsec.org/advisories/RUSTSEC-2020-0041.html
- Mitre: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-25795
- Bug Report GitHub Issue/Release: https://github.com/bodil/sized-chunks/issues/11
- Bug Fix GitHub Commit/PR: https://github.com/bodil/sized-chunks/pull/15

> An issue was discovered in the sized-chunks crate through 0.6.2 for Rust. In the Chunk implementation,insert_from can have a memory-safety issue upon a panic.

## Source

The code of `insert_from`:

```rust
pub fn insert_from<Iterable, I>(&mut self, index: usize, iter: Iterable)
    where
        Iterable: IntoIterator<Item = A, IntoIter = I>,
        I: ExactSizeIterator<Item = A>,
{
    let iter = iter.into_iter();
    let insert_size = iter.len();
    if self.len() + insert_size > Self::CAPACITY {
        panic!(
            "Chunk::insert_from: chunk cannot fit {} elements",
            insert_size
        );
    }
    if index > self.len() {
        panic!("Chunk::insert_from: index out of bounds");
    }
    let real_index = index + self.left;
    let left_size = index;
    let right_size = self.right - real_index;
    if self.right == N::USIZE || (self.left >= insert_size && left_size < right_size) {
        unsafe {
            Chunk::force_copy(self.left, self.left - insert_size, left_size, self);
            let mut write_index = real_index - insert_size;
            for value in iter {
                Chunk::force_write(write_index, value, self);
                write_index += 1;
            }
        }
        self.left -= insert_size;
    } else if self.left == 0 || (self.right + insert_size <= Self::CAPACITY) {
        unsafe {
            Chunk::force_copy(real_index, real_index + insert_size, right_size, self);
            let mut write_index = real_index;
            for value in iter {
                Chunk::force_write(write_index, value, self);
                write_index += 1;
            }
        }
        self.right += insert_size;
    } else {
        unsafe {
            Chunk::force_copy(self.left, 0, left_size, self);
            Chunk::force_copy(real_index, left_size + insert_size, right_size, self);
            let mut write_index = left_size;
            for value in iter {
                Chunk::force_write(write_index, value, self);
                write_index += 1;
            }
        }
        self.right -= self.left;
        self.right += insert_size;
        self.left = 0;
    }
}
```

The way to trigger the panic is to pass an Panicking iterator to `insert_from`, see the issue.

## Description / Analysis

TODO

## Fixes

TODO

## Pattern Description

TODO