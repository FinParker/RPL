# CVE-2020-35881

## Metadata

- RustSec: https://rustsec.org/advisories/RUSTSEC-2020-0027.html
- Mitre: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-35881
- Bug Report GitHub Issue/Release: https://github.com/reem/rust-traitobject/issues/7
- Bug Fix GitHub Commit/PR: https://github.com/reem/rust-traitobject/commit/99b1993a13bf80e93031048586526384d1d8bddc

## Source

```rust
/// Get the data pointer from this trait object, mutably.
///
/// Highly unsafe, as there is no information about the type of the data.
pub unsafe fn get_data<T: ?Sized>(val: *const T) -> *const () {
    *mem::transmute::<*const *const T, *const *const ()>(&val)
}
```

## Description / Analysis

### Intorduction to "Fat Pointers"

"Fat pointer" is used to refer to references and raw pointers to dynamically sized types (DSTs) â€“ slices or trait objects.

Each instance of a pointer to a trait object includes:

- a pointer to an instance of a type T that implements SomeTrait (i.e. a data pointer).
- a virtual method table, which contains, for each method of SomeTrait and its supertraits that T implements, a pointer to T's implementation (i.e. a function pointer).

A reference to a trait object is basically represented as:

```rust
struct TraitObjectRef {
    data_ptr: *const (),
    vtable_ptr: *const (),
}
```

However, the Rust Compiler does not expose the layout of "fat pointers" to the user, i.e., we **cannot** assume that the data pointer is the first 8 bytes of the reference/raw pointer.


### A simple example 

Here is a simpler example with the wrong assumption:

```rust
fn test() {
    let mut val = 7_u32;
    let fat_ptr = &mut val as &mut dyn Send;
    println!("size of &dyn Send: {}", std::mem::size_of_val(&fat_ptr)); // 16

    let (data_ptr, _vtable_ptr): (&mut u32, &mut u32) = unsafe {
        mem::transmute(fat_ptr)
    };
    *data_ptr += 1_u32;
    println!("val: {}", val); // 8
}
```

### The CVE's example 

The function `get_data` is supposed to extract the data pointer from a trait object.

```rust
pub unsafe fn get_data1<T: ?Sized>(maybe_fat_ptr: *const T) -> *const ()
{
    // *const T could be 8 bytes or 16 bytes:
    //     - if T is a trait object, it's 16 bytes
    //     - if T is a sized type, it's 8 bytes
    let ptr_to_maybe_fat_ptr: *const *const T = &maybe_fat_ptr;
    let ptr_to_data_ptr: *const *const () = mem::transmute(ptr_to_maybe_fat_ptr);
    let data_ptr: *const () = *ptr_to_data_ptr;
    data_ptr
}
```

### Another example in [dyn_derive](https://github.com/shigma/dyn_derive/blob/main/dyn_std/src/any.rs)

```rust
pub trait Fat<T: ?Sized>: AsRef<T> + Sized {
    fn into_box(self, f: impl FnOnce(Self) -> *mut ()) -> Box<T> {
        let mut fat_ptr = self.as_ref() as *const T;
        let data_ptr = &mut fat_ptr as *mut *const T as *mut *mut ();
        unsafe {
            *data_ptr = f(self);
            Box::from_raw(fat_ptr as *mut T)
        }
    }

    fn to_box(self, f: impl FnOnce(&T) -> *mut ()) -> Box<T> {
        let mut fat_ptr = self.as_ref() as *const T;
        let data_ptr = &mut fat_ptr as *mut *const T as *mut *mut ();
        unsafe {
            *data_ptr = f(self.as_ref());
            Box::from_raw(fat_ptr as *mut T)
        }
    }
}
```

## Fixes

```rust
pub unsafe fn get_data<T: ?Sized>(val: *const T) -> *const() {
    val as *const ()
}
```

Do not know if this is correct.

## Pattern Description

TODO
