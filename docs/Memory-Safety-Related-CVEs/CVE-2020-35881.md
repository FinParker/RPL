# CVE-2020-35881

## Metadata

- RustSec: https://rustsec.org/advisories/RUSTSEC-2020-0027.html
- Mitre: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-35881
- Bug Report GitHub Issue/Release: https://github.com/reem/rust-traitobject/issues/7
- Bug Fix GitHub Commit/PR: https://github.com/reem/rust-traitobject/commit/99b1993a13bf80e93031048586526384d1d8bddc

## Source

```rust
/// Get the data pointer from this trait object, mutably.
///
/// Highly unsafe, as there is no information about the type of the data.
pub unsafe fn get_data<T: ?Sized>(val: *const T) -> *const () {
    *mem::transmute::<*const *const T, *const *const ()>(&val)
}
```

## Description / Analysis

"Fat pointer" is used to refer to references and raw pointers to dynamically sized types (DSTs) â€“ slices or trait objects. In the case of trait objects, the additional data that completes the DST is a pointer to the vtable (the vptr). A reference to a trait object is basically represented as:

```rust
struct TraitObjectRef {
    data_ptr: *const (),
    vtable_ptr: *const (),
}
```

However, the Rust Compiler does not expose the layout of "fat pointers" to the user, i.e., we **cannot** assume that the data pointer is the first 8 bytes of the reference/raw pointer.

Here is a simpler example with the wrong assumption:

```rust
fn test() {
    let mut val = 7_u32;
    let fat_ptr = &mut val as &mut dyn Send;
    println!("size of &dyn Send: {}", std::mem::size_of_val(&fat_ptr)); // 16

    let (data_ptr, _vtable_ptr): (&mut u32, &mut u32) = unsafe {
        mem::transmute(fat_ptr)
    };
    *data_ptr += 1_u32;
    println!("val: {}", val); // 8
}
```

The function `get_data` is supposed to extract the data pointer from a trait object.

```rust
pub unsafe fn get_data1<T: ?Sized>(maybe_fat_ptr: *const T) -> *const ()
{
    // *const T could be 8 bytes or 16 bytes:
    //     - if T is a trait object, it's 16 bytes
    //     - if T is a sized type, it's 8 bytes
    let ptr_to_maybe_fat_ptr: *const *const T = &maybe_fat_ptr;
    let ptr_to_data_ptr: *const *const () = mem::transmute(ptr_to_maybe_fat_ptr);
    let data_ptr: *const () = *ptr_to_data_ptr;
    data_ptr
}
```

## Fixes

```rust
pub unsafe fn get_data<T: ?Sized>(val: *const T) -> *const() {
    val as *const ()
}
```

## Pattern Description

TODO
