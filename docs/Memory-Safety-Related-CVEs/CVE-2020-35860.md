# CVE-2020-35860

## Metadata

- RustSec: https://rustsec.org/advisories/RUSTSEC-2020-0005.html
- Mitre: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-35860
- Bug Report GitHub Issue/Release: https://github.com/TomBebbington/cbox-rs/issues/2
- Bug Fix GitHub Commit/PR: _

## Source

```rust
extern crate libc;

use std::{ffi::CStr, ops::Deref};

use libc::{free, c_void, c_char};

pub trait DisposeRef {
    /// What a reference to this type represents as a C pointer.
    type RefTo;
    /// Destroy the contents at the pointer's location.
    ///
    /// This should run some variant of `libc::free(ptr)`
    unsafe fn dispose(ptr: *mut Self::RefTo) {
        free(ptr as *mut c_void);
    }
}

impl DisposeRef for str {
    type RefTo = c_char;
}

pub struct CBox<D:?Sized> where D:DisposeRef {
    pub ptr: *mut D::RefTo
}


impl<D:?Sized> CBox<D> where D:DisposeRef {
    #[inline(always)]
    /// Wrap the pointer in a `CBox`.
    pub fn new(ptr: *mut D::RefTo) -> Self {
        CBox {
            ptr
        }
    }
    #[inline(always)]
    /// Returns the internal pointer.
    pub unsafe fn as_ptr(&self) -> *mut D::RefTo {
        self.ptr
    }
    #[inline(always)]
    /// Returns the internal pointer.
    pub unsafe fn unwrap(self) -> *mut D::RefTo {
        let ptr = self.ptr;
        std::mem::forget(self);
        ptr
    }
}

impl<'a> Deref for CBox<str> {
    type Target = str;
    fn deref(&self) -> &str {
        unsafe {
            let text = CStr::from_ptr(self.ptr);
            std::str::from_utf8_unchecked(text.to_bytes())
        }
    }
}
```

## Description / Analysis

The function signature of `CStr::from_ptr` is as follows:

```rust
pub unsafe fn from_ptr<'a>(ptr: *const i8) -> &'a CStr
```

The safety requirements for this function are as follows:

- The memory pointed to by ptr must contain a valid nul terminator at the end of the string.

- ptr must be valid for reads of bytes up to and including the nul terminator. This means in particular:

  - The entire memory range of this CStr must be contained within a single allocated object!
  - **ptr must be non-null even for a zero-length cstr**.

- The memory referenced by the returned CStr must not be mutated for the duration of lifetime 'a.

- The nul terminator must be within isize::MAX from ptr

## Fixes

No fix has been implemented yet. However, the following fix is recommended:

```rust
impl<'a> Deref for CBox<str> {
    type Target = str;
    fn deref(&self) -> &str {
        unsafe {
            if self.ptr.is_null() {
                return "";
            } else {
                let text = CStr::from_ptr(self.ptr);
                std::str::from_utf8_unchecked(text.to_bytes())
            }
        }
    }
}
```

## Pattern Description

````rpl
pattern CVE-2020-35860

mvar {
    CBox: adt
    ptr: field
    new: span
    m: mutability
    call: span
}

util {
    p_cbox = pub adt $CBox {
        self.**.$ptr: *$m c_char,
    }

    p_cbox_new = impl $CBox {
        #span![$new]
        pub fn _(from_ptr: *$m c_char) -> Self {
            $CBox { $ptr: from_ptr }
        }
    }

    p_cbox_deref = impl Deref for $CBox {
        type Target = _;
        fn deref(&self) -> Self::Target {
            let cstr = unsafe { #span!($call, CStr::from_ptr(self.ptr)) };
        }
    }
}

patt {
    p: err = & p_cbox
        & p_cbox_new
        & p_cbox_deref => UnsafePtr {
            $call,
            $ptr,
            $new,
        }
}

use {
    std::ffi::CStr,
    std::ops::Deref,
}

diag {
    #[derive(Diagnostic)]
    #[diag(unsafe_ptr)]
    pub struct UnsafePtr {
        #[primary_span]
        pub call: Span,
        pub ptr: Ident,
        #[label]
        pub new: Span,
    }
}

msg {
    unsafe_ptr = use unsafe pointer constructed from any pointer
        .label = unsound constructor defined here
}
````
