# CVE-2020-35892-3

## Metadata

- RustSec: https://rustsec.org/advisories/RUSTSEC-2020-0039.html
- Mitre: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-35892
- Bug Report GitHub Issue/Release: https://github.com/nathansizemore/simple-slab/issues/2
- Bug Fix GitHub Commit/PR: [TODO](https://github.com/nathansizemore/simple-slab/commit/5e0524c1db836e2192e1cd818848d96937c0b587)

## Source

```rust
impl<T> Index<usize> for Slab<T> {
    type Output = T;
    fn index(&self, index: usize) -> &Self::Output {
        unsafe { &(*(self.mem.offset(index as isize))) }
    }
}
```

```rust
#[inline]
pub fn remove(&mut self, offset: usize) -> T {
    assert!(offset < self.len, "Offset out of bounds");

    let elem: T;
    let last_elem: T;
    let elem_ptr: *mut T;
    let last_elem_ptr: *mut T;

    unsafe {
        elem_ptr = self.mem.offset(offset as isize);
        last_elem_ptr = self.mem.offset(self.len as isize);

        elem = ptr::read(elem_ptr);
        last_elem = ptr::read(last_elem_ptr);

        ptr::write(elem_ptr, last_elem);
    }

    self.len -= 1;
    return elem;
}
```

## Description / Analysis

- Slab::index() does not perform the boundary checking, which leads to out-of-bound read access.
- Slab::remove() copies an element from an invalid address due to off-by-one error, resulting in memory leakage and uninitialized memory drop.

## Fixes

For first,

```rust
assert!(index < self.len, "Index out of bounds");
```

For second,

```rust
last_elem_ptr = self.mem.offset((self.len - 1) as isize);
```
