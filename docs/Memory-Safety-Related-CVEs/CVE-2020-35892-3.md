# CVE-2020-35892-3

## Metadata

- RustSec: https://rustsec.org/advisories/RUSTSEC-2020-0039.html
- Mitre: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-35892
- Bug Report GitHub Issue/Release: https://github.com/nathansizemore/simple-slab/issues/2
- Bug Fix GitHub Commit/PR: [TODO](https://github.com/nathansizemore/simple-slab/commit/5e0524c1db836e2192e1cd818848d96937c0b587)

## Source

```rust
impl<T> Index<usize> for Slab<T> {
    type Output = T;
    fn index(&self, index: usize) -> &Self::Output {
        unsafe { &(*(self.mem.offset(index as isize))) }
    }
}
```

```rust
#[inline]
pub fn remove(&mut self, offset: usize) -> T {
    assert!(offset < self.len, "Offset out of bounds");

    let elem: T;
    let last_elem: T;
    let elem_ptr: *mut T;
    let last_elem_ptr: *mut T;

    unsafe {
        elem_ptr = self.mem.offset(offset as isize);
        last_elem_ptr = self.mem.offset(self.len as isize);

        elem = ptr::read(elem_ptr);
        last_elem = ptr::read(last_elem_ptr);

        ptr::write(elem_ptr, last_elem);
    }

    self.len -= 1;
    return elem;
}
```

## Description / Analysis

- Slab::index() does not perform the boundary checking, which leads to out-of-bound read access.
- Slab::remove() copies an element from an invalid address due to off-by-one error, resulting in memory leakage and uninitialized memory drop.

## Fixes

For first,

```rust
assert!(index < self.len, "Index out of bounds");
```

For second,

```rust
last_elem_ptr = self.mem.offset((self.len - 1) as isize);
```

## Pattern Description

````rpl
pattern CVE-2020-35892-3

mvar {
    S: adt
    self: ident
    T: ty
    len: field
    ptr: field
    index: ident
    self_len: span
}

util {
    pat_struct = pub adt $S {
        self.**.$ptr: *mut $T,
        self.**.$len: usize,
    }

    p_drop_slice = impl Drop for $S {
        fn drop(&mut self) {
            let slice: *mut [$T] = core::ptr::slice_from_raw_parts_mut(self.$ptr, self.$len);
            unsafe { drop_in_place(slice) };
        }
    }

    p_drop_loop = impl Drop for $S {
        fn drop(&mut self) {
            for i in 0..self.$len {
                let ptr: *mut $T = self.$ptr.add(i);
                unsafe { drop_in_place(slice) };
            }
        }
    }

    pat_index = ?pub ?unsafe fn _(_) -> _ {
        let $self: &$S = _;
        let $index: usize = _;
        #without!(if $index < #span!($self_len, $self.$len)) {
            let ptr: *mut $T = $self.$ptr.add(index);
            unsafe { #span!($access_ptr, #access!(ptr)) };
        }
    }

    pat_off_by_one = ?pub ?unsafe fn _(...) -> $(_) {
        let $self: &$S = _;
        let ptr: *mut $T = $self.$ptr.add(self.$len);
        unsafe { #span!($access_ptr, #access!(ptr)) };
    }
}

patt {
    p_index: err = & pat_struct
        & (pat_drop_slice | pat_drop_loop)
        & pat_index => IndexOverflow {
            $access_ptr,
            init_span: $access_ptr.shrink_to_lo(),
            self_len: snippet($self_len),
            $index,
        }
    p_off_by_one: err = & pat_struct
        & (pat_drop_slice | pat_drop_loop)
        & pat_off_by_one => OffsetByOneError {
            $access_ptr,
        }
}

use {
    core::ptr::drop_in_place
}

diag {
    #[derive(Diagnostic)]
    #[diag(index_overflow)]
    pub struct IndexOverflow {
        #[primary_span]
        pub access_ptr: Span,
        #[suggestion(code = "assert!({index} < {self_len});")]
        pub init_span: Span,
        pub self_len: String,
        pub index: Ident,
    }

    #[derive(Diagnostic)]
    #[diag(off_by_one_error)]
    pub struct OffByOneError {
        #[primary_span]
        pub access_ptr: Span,
    }
}

msg {
    index_overflow = access an overflowing pointer
        .suggestion = try asserting `{$index}` in bound

    off_by_one = access an off-by-one pointer
}
````