pattern uninit-vec

patt {
    use std::vec::Vec;
    use std::default::Default;

    #[diag = "uninit_vec"]
    #[const(msg = "calling `set_len()` immediately after reserving a buffer creates uninitialized values")]
    with_capacity[$T: type where !can_be_uninit(self)] = unsafe? fn _(..) -> _ {
        'vec:
        let $vec: Vec<$T> = Vec::with_capacity(_);
        let $vec_ref: &mut Vec<$T> = &mut $vec;
        'set_len:
        _ = Vec::set_len(move $vec_ref, _);
    }
    #[diag = "uninit_vec"]
    #[const(msg = "calling `set_len()` immediately after reserving a buffer creates uninitialized values")]
    reserve[$T: type where !can_be_uninit(self), $vec: place(Vec<$T>)] = unsafe? fn _(..) -> _ {
        let $vec_ref: &mut Vec<$T> = &mut $vec;
        _ = Vec::reserve(move $vec_ref, _);
        'set_len:
        _ = Vec::set_len(move $vec_ref, _);
    }

    #[diag = "uninit_vec"]
    #[const(msg = "calling `set_len()` on empty `Vec` creates out-of-bound values")]
    new[$T: type where !can_be_uninit(self)] = unsafe? fn _(..) -> _ {
        'vec:
        let $vec: Vec<$T> = Vec::new();
        let $vec_ref: &mut Vec<$T> = &mut $vec;
        'set_len:
        _ = Vec::set_len(move $vec_ref, _);
    }
    #[diag = "uninit_vec"]
    #[const(msg = "calling `set_len()` on empty `Vec` creates out-of-bound values")]
    default[$T: type where !can_be_uninit(self)] = unsafe? fn _(..) -> _ {
        'vec:
        let $vec: Vec<$T> = Default::default();
        let $vec_ref: &mut Vec<$T> = &mut $vec;
        'set_len:
        _ = Vec::set_len(move $vec_ref, _);
    }
}

diag {
    uninit_vec = {
        primary(vec, set_len) = "{$msg}",
        help                  = "initialize the buffer or wrap the content in `MaybeUninit`",
        name                  = "uninit_vec",
    }
}
