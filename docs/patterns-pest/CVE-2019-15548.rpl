pattern CVE-2019-15548 

patt {
    use libc::c_char;
    use std::string::String;
    use std::vec::Vec;
    use std::ptr::NonNull;

    p_rust_str_as_c_str[
        $T: type
    ] = fn _ (..) -> _ {
        'cast_from:
        let $src: &String = _;
        let $vec: &Vec::<u8> = &((*$src).vec);
        let $vec_non_null: NonNull::<u8> = copy (*$vec).buf.inner.ptr.pointer;
        let $vec_ptr: *const u8 = copy $vec_non_null as *const u8 (Transmute);
        let $vec_len: usize = copy ((*$vec).len);
        let $bytes_ptr: *const [u8] = *const [u8] from (copy $vec_ptr, copy $vec_len);
        let $bytes: &[u8] = &(*$bytes_ptr);
        let $bytes_ptr_2: *const [u8] = &raw const (*$bytes);
        let $ptr: *const u8 = move $bytes_ptr_2 as *const u8 (PtrToPtr);
        'cast_to:
        let $dst: *const c_char = copy $ptr as *const c_char (Transmute);
        let $ret: $T = $crate::ll::instr(move $dst);
    }
}

diag {
    p_rust_str_as_c_str = {
        primary(cast_to) = "it is usually a bug to cast a `&str` to a `*const libc::c_char`, and then pass it to an extern function",
        label(cast_from) = "the string is here",
        label(cast_to) = "the string is casted to a `*const libc::c_char` here",
        help = "try `std::ffi::CStr` instead",
        level = "deny",
        name = "rust_str_as_c_str",
    }
}