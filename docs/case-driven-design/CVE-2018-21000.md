# CVE-2018-21000

## 任务

描述 CVE-2018-21000 的缺陷模式

## 漏洞源代码

```rust
use std::mem::{size_of, forget};
use std::vec::Vec;

pub unsafe fn guarded_transmute_vec_permissive<T>(mut bytes: Vec<u8>) -> Vec<T> {
    // PermissiveGuard::check::<T>(&bytes).unwrap();
    let ptr = bytes.as_mut_ptr();
    let capacity = bytes.capacity() / size_of::<T>();
    let len = bytes.len() / size_of::<T>();
    forget(bytes);
    Vec::from_raw_parts(ptr as *mut T, capacity, len)
}

pub unsafe fn guarded_transmute_to_bytes_vec<T>(mut from: Vec<T>) -> Vec<u8> {
    let capacity = from.capacity() * size_of::<T>();
    let len = from.len() * size_of::<T>();
    let ptr = from.as_mut_ptr();
    forget(from);
    Vec::from_raw_parts(ptr as *mut u8, capacity, len)
}
```

## 模式

````rust
T1: ty
T2: ty

func: ident
vec: ident
ptr: ident
cap: ident
len: ident

p = ```rust
    pub fn $func<$$(_:GArgs)> (mut $vec: Vec<$T1>) -> Vec<$T2> {
        unordered! {
            let $ptr = $vec.as_mut_ptr();
            let $cap = $vec.capacity() / size_of::<$T2>();
            let $len = $vec.len() / size_of::<$T2>();
        }
        forget($vec);
        Vec::from_raw_parts($ptr as *mut $T2, $cap, $len)
    }
    ```
````

## 解释：

1. \$\$(\_:GArgs)：用于捕获一个或多个泛型参数;
2. `unordered!`：用于在顺序有关的模式中，表达顺序无关的匹配;在本例子中，函数的语句是顺序有关的，而`$ptr`、`$cap`、`$len`的声明是顺序无关的;
3. `forbid!`: 用于描述禁止出现其中的一条或多条语句;

## 新方案

````rust
p1(T1, T2, op) = ```rust
    pub fn $func<$$(_:GArgs)> (mut $vec: Vec<$T1>) -> Vec<$T2> {
        unordered! {
            let $ptr = $vec.as_mut_ptr();
            let $cap = $vec.capacity() $op size_of::<$T2>();
            let $len = $vec.len() $op size_of::<$T2>();
        }
        forget($vec);
        Vec::from_raw_parts($ptr as *mut $T2, $cap, $len)
    }
```

p1(T1, u8, *)
````

## 几点需要考虑的事情

1. 同名覆盖的事情。
2. 前置条件 u8 的事情；上面的新方案中似乎解决了这一点；
3. 没写的语句、模式匹配的默认规则是什么？比如可以出现和元变量只读的语句；
4. 对于对vec可变的修改如何抽象？
> 具体来说，怎么把
> forbid! {
>   $vec.pop();
>   $vec.remove(_);
>   $vec.set_len(_);
>   // ... more operations that may change the length and capacity of the vector
> }
> 抽象的更高级
